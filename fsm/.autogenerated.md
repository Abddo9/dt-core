<div id='fsm-autogenerated' markdown='1'>


<!-- do not edit this file, autogenerated -->

## Package information 

[Link to package on Github](github:org=duckietown,repo=Software,path=20-indefinite-navigation/fsm,branch=master)

### Essentials {nonumber="1"}

Author: [Michael Misha Novitzky](mailto:novitzky@mit.edu)

Maintainer: [Mack](mailto:mack@duckietown.org)

### Description {nonumber="1"}

The finite state machine coordinates the modes of the car. 
  



</div>

<!-- file start -->

<div id='fsm-fsm_node-autogenerated' markdown='1'>


<!-- do not edit this file, autogenerated -->

(Generated from [configuration `fsm_node.easy_node.yaml`](github:org=duckietown,repo=Software,path=fsm_node.easy_node.yaml,branch=master).)

This node handles the state transitions based on the defined state transition events. Below is a summary of the basic functionality of the `fsm_node`.

* Each state is a mode that the Duckiebot can be in
* Each state has corresponding state transitions triggered by events
* Each event is triggered by a certain value of a certain topic message
* In each state, certain nodes are active
* Each node affected by the state machine can be switched active/inactive by a `~/switch` topic

The current state is published to the `fsm_node/mode` topic. For each state, there is a list of nodes which should be active.

The FSM node publishes on many topics according to the configuration:

    for node_name, topic_name in nodes.items():
        self.pub_dict[node_name] = rospy.Publisher(topic_name, BoolStamped, ...)

where `nodes.items()` is a list of all nodes affected by the FSM, and the `topic_name` is `node_name/switch`. The relevant nodes then subscribe to `~/switch`, and toggle their behaviour based on the value of the switch. An example of how a node named `ExampleNode` can handle this is shown below:

    class ExampleNode(object):
        def \__init\__(self):
        ...
        self.sub_switch = rospy.Subscriber("~switch",BoolStamped, self.cbSwitch, queue_size=1)

        def cbSwitch(self,switch_msg):
            self.active = switch_msg.data # True or False

        def someOtherFunc(self, msg):
            if not self.active:
                return
            # else normal functionality
            ...

Nodes may also subscribe to the `fsm_node/mode` topic if their functionality must change for different states (other than just active/inactive).


### Parameters {nonumber="1"}

**Parameter `states`**: `dict`; default value: `{}`

States are the modes that the system can be in. Each state has corresponding events (which trigger transitions to specific states), as well as a list of active nodes in the current state.

**Parameter `nodes`**: `dict`; default value: `{}`

These are the nodes which are affected by the FSM, and also define the `~/switch` topics to switch them between active and inactive.

**Parameter `global_transitions`**: `dict`; default value: `{}`

These are the state transition events (and corresponding topic) that can be triggered from all states.

**Parameter `initial_state`**: `str`; default value: `'LANE_FOLLOWING'`

This is the initial state that the FSM will be in upon launch of the node.

**Parameter `events`**: `dict`; default value: `{}`

These are the events and the corresponding topics (and message values) which trigger them, which allow for transitions between states.

### Subscriptions {nonumber="1"}

No subscriptions defined.

### Publishers {nonumber="1"}

**Publisher `mode`**: topic `~mode` (`FSMState`)

This topic gives the current state of the FSM, and can have values from a set of strings indicating the possible state names.



</div>